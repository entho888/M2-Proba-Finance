#%%
#Libraries
import numpy as np 
import matplotlib.pyplot as plt
import scipy
import seaborn as sns 


"""
sq = np.random.SeedSequence()
seed = sq.entropy
print('seed = ', seed)
"""
rng = np.random.default_rng(1)




def uniform_distribution(low=float, high=float, size=None, random_state: np.random.Generator=rng) :
    """Return an independent sample of size "size" of uniform distribution over 
    the interval [low, high).

    Args:
        low (float): lower bound of the interval the generated numbers are in
        high (float): upper bound of the interval the generated numbers are in
        size (tuple): output shape. if the given shape is (m,n,k) then m*n*k samples are generated. 
            Default is None, in the case the function returns a single value.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        Array of random floats of shape "size".
    """
    if low > high : 
        print("Error from 'uniform_distribution' function of 'simulation' : lower bound of interval greater than upper bound")
        return 

    return (high - low)*random_state.random(size=size) + low


def exponential_distribution(lamda=float, size=None, random_state: np.random.Generator=rng) :
    """exponential_distribution : Return an independent sample of shape "size" of 
    exponential distribution of parameter lambda = lamda. 
    Density is lamda*np.exp(-lamda*x).
    Generated by the inverse distribution function method.

    Args:
        lamda (float, optional): non negativ float, parameter of the exponential distribution.
            Defaults to float.
        size (tuple, optional): output shape. if given shape is (m,,n,k) then m*n*k samples are generated.
            Defaults to None.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns :   
        Array of random floats of shape "size".
    """

    if lamda <= 0 : 
        print("Error from 'exponential_distribution' function of 'simulation' : parameter lambda is negativ")
        return

    return (-1/lamda)*np.log(random_state.random(size=size))


def bernoulli(p=float, size=None, random_state: np.random.Generator=rng) :
    """Bernoulli distribution

    Return an array of shape 'size' of independent random variables of law bernoulli('p').

    Args:
        p (float, optional): Float between 0 and 1. Parameter of the law. Defaults to float.
        size (tuple, optional): shape of the output. Defaults to None.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.
    """
    if (p < 0) or (p >1) :
        print("Error in 'bernoulli' function of 'simulation' : p must be include in [0,1]")
        return

    def jump_function(x) :
        if x < p : return 1
        else: return 0

    jump_function_vectorized = np.vectorize(jump_function)

    return jump_function_vectorized(random_state.random(size=size))


def Pascal_triangle(row_number) :
    """Pascal_triangle : Return a list of all binomial coefficients of 'degree' equal to
    'row_number'. Let's say row_number is equal to 2 then it returns [1,2,1].
    It uses the pascal triangle relation.

    Args:
        row_number (int): positiv integer, is equal to the 'degree' in the 
        binomial relation of Newton

    Returns:
        List : list of the binomial coefficents of 'degree' equal to 'row_number'
    """

    if row_number < 0 : 
        print("Error from 'Pascal_triangle' function of 'simulation' : row_number is negativ")
        return

    present_Row = []
    past_Row = [1]

    for i in range(1, row_number+1) :
        present_Row.append(1)
        for j in range(1, i) :
            present_Row.append(past_Row[j-1] + past_Row[j])
        present_Row.append(1)

        past_Row = present_Row
        present_Row = []

    return past_Row


def binomial(n=int, p=float, size = None, random_state: np.random.Generator=rng) :
    """binomial : Return an independent sample of shape 'size' of binomial 
    distribution of parameter 'n' and 'p'. 
    Generated by the inverse distribution function method.

    Args:
        n (int, optional): non negativ integer, maximum number the distribution may take.
         Defaults to int.
        p (float, optional): float between 0 and 1, parameter of the law.
         Defaults to float.
        size (tuple, optional): output shape. if given shape is (m,,n,k) then m*n*k samples are generated.
         Defaults to None.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        Array: array of random positiv integer lower than 'n' following the binomial(n,p) distribution.
    """

    if (n <= 0) :
        print("Error in 'binomial' function of 'simulation' : n is negativ")
        return
    if (p < 0) or (p >1) :
        print("Error in 'binomial' function of 'simulation' : p must be include in [0,1]")
        return

    binomial_coefficients = Pascal_triangle(n)
    cumulated_probability_list = [0]

    Sum = 0
    for k in range(n) :
        Sum += binomial_coefficients[k]*(p**(k))*((1-p)**(n-k))
        cumulated_probability_list.append(Sum)
    cumulated_probability_list.append(1)

    def multiple_jumps_function(x) :
        for k in range(len(cumulated_probability_list)-1) :
            if x >= cumulated_probability_list[k] and x < cumulated_probability_list[k+1] :
                return k

    multiple_jumps_function_vect = np.vectorize(multiple_jumps_function)

    return multiple_jumps_function_vect(random_state.random(size=size))
    

def box_muller_method(size = 1, random_state: np.random.Generator=rng) :
    """Implementation of the Box-Muller method to draw independent samples of standard normal distribution 
    (centered and variance is identity). 

    Args:
        size (tuple): shape of the output
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        Array of shape 'size' of independent draws of standard normal distribution.
    """

    try :

        iteration_number = int(np.ceil(np.prod(size)/2)) #number of iteration of the method needed
        uniform_sample = random_state.random((iteration_number,2))
        normal_sample = []

        for i in range(iteration_number) :
            u1, u2 = uniform_sample[i,]
            exponential = (-2*np.log(u1))**(.5)
            uniform_angle = 2*np.pi*u2

            normal_sample.extend((exponential*np.cos(uniform_angle), exponential*np.sin(uniform_angle)))

        return (np.array(normal_sample[:np.prod(size)])).reshape(size)

    except TypeError :
        print("Enter an int")
        raise
    except ValueError :
        print("Enter a non negativ int")
        raise


def uniform_unit_ball(dimension: int=1, size = 1, random_state: np.random.Generator=rng) :
    """uniform_unit_ball : Return a list of length 'size' of independent realisations of
    uniform distribution over the unit ball of the real space to the power of 'dimension'.
    Generated using the acceptance-reject method.
    It's the unit ball for the L2 norm.

    Args:
        dimension (int, optional): dimension of the space of the ball. Defaults to 1.
        size (tuple, optional): 'shape of the output'. The function draws a sample of shape 'size'
            following the uniform unit ball distribution of dimension 'dimension'.
            Defaults to 1.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.
        
    Returns :
        Array of shape 'dimension, size' containing independent draws of uniform distribution over the unit ball of R**(dimension).
    """

    iteration_number = np.prod(size)
    U = np.empty((dimension, iteration_number))

    for i in range(iteration_number)  :
        u = 2*np.ones(dimension)

        while np.linalg.norm(u) > 1 :
            u = np.array(uniform_distribution(-1,1,dimension, random_state = random_state))
        
        U[:,i] = u

    if type(size) == int :
        return np.array(U).reshape((dimension, size))

    else : 
        return np.array(U).reshape((dimension,) + size)


def marsaglia_method(size = 1, random_state: np.random.Generator=rng) :
    """Implementation of the Marsaglia's polar method to draw independent draws of standard normal distribution 
    (centered and variance is identity). 

    Improvements to make : vectorize more, don't use a loop and generate a fixed number of uniform[0,1] chose so
    we accept at least 'size' points with high probability (cf : https://quantgirl.blog/comparing-box-muller-and-marsaglia-bray/)

    Args:
        size (tuple): shape of the output
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        Array of shape 'size' of independent draws of standard normal distribution.
    """

    try :
        iteration_number = int(np.ceil(np.prod(size)/2)) #number of iteration of the method needed
        normal_sample = []

        for i in range(iteration_number) :
            r=2
            while r > 1 :
                x, y = 2*random_state.random(2) - 1
                r = x**2 + y**2
            
            temp = (-2*np.log(r)/r)**(.5)

            normal_sample.extend((temp*x, temp*y))

        return (np.array(normal_sample[:np.prod(size)])).reshape(size)

    except TypeError :
        print("Enter an int")
        raise
    except ValueError :
        print("Enter a non negativ int")
        raise


def gaussian_vector_distribution(size =1, mu = 0, sigma = 1, cholesky: bool=True, 
                                method = 'default',
                                random_state: np.random.Generator=rng) :
    """gaussian_distribution : Return a gaussian vector of mean 'mu' and covariance matrix
    'sigma'. 
    Possibility to choose the method of generation used.

    Args:
        size (tuple) : 'shape of the output'. The function draws a sample of shape 'size'
            following the uniform unit ball distribution of dimension 'dimension'.
            Defaults to 1.
        mu (array_like): 1d array, mean vector of the gaussian vector
        sigma (array_like): 2d array of shape (n,n), where n is the shape of mu. Sigma
            is the matrix of the covariances between the variables within our gaussian vector.
            The function assumes that sigma really is a covariance matrix.
        cholesky (Boolean): if equals to 'True' then the algorithm will use the Cholesky Decomposition.
            Otherwise, it uses scipy.linalg.sqrtm. 
        method (string): method is either 'default', 'bm', 'marsaglia'. If method is 'default', the standard gaussians
            will be generated by the function of numpy. If methode is 'bm', it will use the function 'box_muller_method'
            and if its 'marsaglia' it will use 'marsaglia_method'. Defaults to 'default'
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        1 array_like with same shape as mu. 
    """

    try : 
        mu, sigma = np.array(mu), np.array(sigma)
        vector_dimension = mu.size
        
        # Dimensions check
        if sigma.size == 1 and vector_dimension == 1 :
            if method == 'default' :
                standard_gaussian = random_state.standard_normal(size)
            elif method == 'bm' :
                standard_gaussian = box_muller_method(size, random_state=random_state)
            elif method == 'marsaglia' :
                standard_gaussian = marsaglia_method(size, random_state=random_state)
            else :
                print("Error in function 'gaussian_vector_distribution' of 'simulation' : method argument is not valid")
                return
            return np.sqrt(sigma)*standard_gaussian + mu*np.ones(size)
        else :
            if sigma.size == 1 and vector_dimension != 1 :
                sigma = sigma*np.eye( vector_dimension )
            else : 
                if sigma.size !=1 and vector_dimension == 1 :
                    mu = mu*np.ones( sigma.shape[0] )
                    vector_dimension = mu.size
                else :
                    if sigma.shape != (vector_dimension,vector_dimension) :
                        print("Error in 'gaussian_vector_distribution' of 'simulation' : shapes of parameters aren't compatible.")
                        return

        # Reshaping mu and drawing the gaussians
        if type(size) == int :
            mu = (np.repeat(mu, size, axis =0)).reshape((vector_dimension, size))
            if method == 'default' :
                standard_gaussian = random_state.standard_normal((vector_dimension, size))
            elif method == 'bm' :
                standard_gaussian = box_muller_method((vector_dimension, size), random_state=random_state)
            elif method == 'marsaglia' :
                standard_gaussian = marsaglia_method((vector_dimension, size), random_state=random_state)
            else :
                print("Error in function 'gaussian_vector_distribution' of 'simulation' : method argument is not valid")
                return
        else :
            mu = (np.repeat(mu, np.prod(size), axis=0)).reshape((vector_dimension,) + size)
            if method == 'default' :
                standard_gaussian = random_state.standard_normal((vector_dimension,) + size)
            elif method == 'bm' :
                standard_gaussian = box_muller_method((vector_dimension,) + size, random_state=random_state)
            elif method == 'marsaglia' :
                standard_gaussian = marsaglia_method((vector_dimension,) + size, random_state=random_state)
            else :
                print("Error in function 'gaussian_vector_distribution' of 'simulation' : method argument is not valid")
                return

        # Easy case : sigma is identity
        if np.allclose( sigma, np.eye(vector_dimension) ) :
            return standard_gaussian + mu

        # Computing square root of the covariance matrix
        if cholesky == True :
            covariance_matrix_sqrt = np.linalg.cholesky(sigma)
        else : 
            covariance_matrix_sqrt = (scipy.linalg.sqrtm(sigma))[0]
            

        return np.einsum('ij,j...->i...', covariance_matrix_sqrt, standard_gaussian) + mu

    except TypeError :
        print("Error in 'gaussian_vector_distribution' of 'simulation' : enter array-like parameters")
        raise


def standard_brownian_motion_1d_timeList(time_list, n_paths: int = 1, 
                                    increments : bool = False,
                                    random_state: np.random.Generator=rng) :
    """Standard brownian motion (1 dimension) generator

    Draw 'n_paths' standard brownian motion using the independant gaussians generated with numpy.
    Generated using independent increasing increments.

    Args:
        time_list (array_like): non decreasing sequence of non negativ float representing time. 
            This function doesn't check the 'non-decreasing' caracteristic so it won't return a brownian motion
            if time_list is not non decreasing.
        n_paths (int): number of paths to generate
        increments (bool) : Determine if we return the increments array or not.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        Array of float representing the values of the brownian motion at times in the time_list.
    """
    #Partial validity check of time_list
    if time_list[-1] <=0 :
        print("Error in 'standard_brownian_motion_1d_timeList' of 'simulation' : arg 'time_list' is not valid (last value not non negativ)")
        return

    n_times = len(time_list) #number of gaussian needed
    gaussian_vector = random_state.normal(loc=0, scale=1, size=(n_times, n_paths))

    Diagonal = np.sqrt( time_list - (np.append(0, (time_list[:-1])))  )
    increments_array = np.diag(Diagonal) @ gaussian_vector

    if increments :
        return increments_array

    return np.cumsum(increments_array, axis = 0)


def standard_brownian_motion_1d_timeParameters(n_times: int, n_paths : int,
                                            final_time: float = 1.0,
                                            increments : bool = False,
                                            random_state: np.random.Generator=rng) :
    """Standard brownian motion (1 dimension) generator

    Draw 'n_paths' standard brownian motion using the independant gaussians generated with numpy.
    Generated using independent increasing increments.

    Args:
        n_times (int): number of timesteps
        n_paths (int): number of paths simulated
        final_time (float, optional): Final time of simulation. Defaults to 1.0.
        increments (bool) : Determine if we return the increments array or not.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        `np.array` of shape `(n_times+1, n_paths)` containing the paths.
    """
    #Validity check of args
    if final_time <=0 :
        print("Error in 'standard_brownian_motion_1d_timeParameters' of 'simulation' : arg 'final_time' is not valid.")
        return

    increments_list = np.sqrt(final_time / n_times) * random_state.standard_normal((n_times, n_paths))
    if increments:
        return increments_list
    else:
        brownian = np.zeros((n_times+1, n_paths))
        brownian[1:] = np.cumsum(increments_list, axis=0)
        return brownian


def refine_brownian_motion_1d(paths, time_list = None, 
                            constant_step : bool = True, 
                            random_state: np.random.Generator=rng) :
    """Refine a given brownian motion (1 dimension):

    For every 2 succesives times, add a point at the middle time on every path. 
    New points are determined using a formula (Lévy) that gives the conditionnal law of a Brownian knowing a point in the past 
    and a point in the future.

    Args:
        paths (2d array): First dimmension is the trajectories, second is the number of trajactories. The brownian motion to refine.
        time_list (1d array like, optional): list of the times associated with the paths. Defaults to None.
        constant_step (bool, optional): determines if the step of the time list is constant or not. Defaults to True.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        If time_list == None : 2d array representing the refined brownian motion.
        Else : 2d array representing the refined brownian motion and its associated new time_list.
    """
    #Partial validity check of time_list
    if time_list[-1] <=0 :
        print("Error in 'refine_brownian_motion_1d' of 'simulation' : arg 'time_list' is not valid (last value not non negativ)")
        return

    n_times, n_paths = paths.shape
    if constant_step == True :
            # We use the expression of the brownian conditionally to his future and past
            temp = (paths.repeat(2, axis=0))
            non_random_part_paths = ( temp[1:,:] + temp[:-1,:] )/2 #creates an offset then calculates the mean
            
            #Step
            if type(time_list) == np.ndarray or type(time_list) == list :
                step = time_list[-1]/(n_times -1)
            else : 
                step = 1/(n_times -1) #We suppose that final_time = 1.0

            #Random part 
            random_part_paths = np.zeros(non_random_part_paths.shape)
            random_part_paths[1::2] = np.sqrt(step/4)*random_state.standard_normal((n_times - 1,n_paths)) #We add the random part to new points

            #Return
            refined_paths = random_part_paths + non_random_part_paths

            if type(time_list) != np.ndarray and type(time_list) != list :
                if time_list == None : 
                    return refined_paths

            else :
                return refined_paths, np.arange(time_list[0], time_list[-1] + step/2, step/2)

    else :
        if type(time_list) != np.ndarray and type(time_list) != list :
            if time_list == None : 
                print("Error in 'refine_brownian_motion_1d' in 'simulation' : arguments are missing")
                return
        else :
            #Deterministic part
            temp = (paths.repeat(2, axis=0))
            non_random_part_paths = ( temp[1:,:] + temp[:-1,:] )/2

            #Random part
            random_part_paths = np.zeros(non_random_part_paths.shape)
            temp = (time_list.repeat(2, axis=0))
            sqrt_covariance_matrix = np.sqrt(( temp[1:] - temp[:-1] ))/2
            random_part_paths[1::2] = (np.diag(sqrt_covariance_matrix)).dot(random_state.standard_normal((n_times - 1,n_paths)))

            #Return
            refined_time_list = ( (time_list.repeat(2, axis=0))[1:,:] + (time_list.repeat(2, axis=0))[:-1,:] )/2

            return non_random_part_paths + random_part_paths, refined_time_list

#test
"""
B1 = standard_brownian_motion_1d_timeParameters(50, 100, final_time = 2.0)
T1 = np.linspace(0, 2, 51, endpoint = True)

B2, T2 = refine_brownian_motion_1d(B1, T1)
B3, T3 = refine_brownian_motion_1d(B2, T2)
B4, T4 = refine_brownian_motion_1d(B3, T3)
Bs = [B1, B2, B3, B4]
TL = [T1, T2, T3, T4]

fig, axs = plt.subplots(ncols=2, nrows=2, figsize=(10,6), 
                        sharex=True, sharey = True, layout='tight')
for n, (paths, ax) in enumerate(zip(Bs, axs.flat)):
    time = TL[n]
    for path in paths.T:
        sns.lineplot(x=time, y=path, color='C0', alpha=0.2, ax=ax)
    ax = sns.lineplot(x=time, y=paths[:,0], color='C1', lw=2, label=f'Iteration n = {n}', ax=ax)
"""


def standard_brownian_motion_2d_timeList(time_list, n_paths: int = 1, 
                                        correlation : float = 0.0,
                                        increments : bool = False,
                                        random_state: np.random.Generator=rng) :
    """Simulated paths of 2d standard brownian motion with correlated components

    Args:
        time_list (array_like): list of times associated with the brownian
        n_paths (int, optional): number of paths. Defaults to 1.
        correlation (float, optional): float between -1 and 1. Correlation between the two components of the brownian. Defaults to 0.0.
        increments (bool, optional): If True, the function returns the increments of the brownian. Defaults to False.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        'np.array' of shape (2, len(time_list), n_paths) containing paths if increments == 'False', containing the increments otherwise.
    """
    #Some arg validity tests
    if time_list[-1] <=0 :
        print("Error in 'standard_brownian_motion_2d_timeList' of 'simulation' : arg 'time_list' is not valid (last value not non negativ)")
        return
    if correlation > 1 or correlation < -1 :
        print("Error in 'standard_brownian_motion_2d_timeList' of 'simulation' : argument 'correlation' is not a correlation")
        return

    no_correlation_2d_increments = np.array([standard_brownian_motion_1d_timeList(time_list=time_list, n_paths = n_paths,
                                                                    increments = True, random_state=random_state),
                                        standard_brownian_motion_1d_timeList(time_list=time_list, n_paths = n_paths,
                                                                    increments = True, random_state=random_state)]) 
    
    correlation_2d_increments = no_correlation_2d_increments.copy()
    correlation_2d_increments[1] = correlation*no_correlation_2d_increments[0] + np.sqrt(1 - correlation**2)*no_correlation_2d_increments[1]

    if increments == True :  
        return correlation_2d_increments

    else :
        return np.cumsum(correlation_2d_increments, axis = 1)

#test
"""
N, M = 50, 2
T = 1
rho = -0.9
times = np.arange(N+1)*(T / N)

W2 = standard_brownian_motion_2d_timeList(times, M, rho)
sns.lineplot(x=times, y=W2[0,:,1], color='C0', label='Dimension 1')
sns.lineplot(x=times, y=W2[1,:,1], color='C1', label='Dimension 2')
"""


def standard_brownian_motion_2d_timeParameters(n_times: int, n_paths : int,
                                            final_time: float = 1.0,
                                            correlation: float = 0.0,
                                            increments: bool = False,
                                            random_state: np.random.Generator=rng) :
    """Simulated paths of 2d standard brownian motion with correlated components

    Args:
        n_times (int): number of timesteps
        n_paths (int): number of paths simulated
        final_time (float, optional): Final time of simulation. Defaults to 1.0.
        correlation (float, optional): float between -1 and 1. Correlation between the two components of the brownian. Defaults to 0.0.
        increments (bool, optional): If True, the function returns the increments of the brownian. Defaults to False.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        'np.array' of shape (2, len(time_list), n_paths) containing paths if increments == 'False', containing the increments otherwise.
    """
    # Some validity checks
    if final_time <=0 :
        print("Error in 'standard_brownian_motion_2d_timeParameters' of 'simulation' : arg 'final_time' is not valid.")
        return
    if correlation > 1 or correlation < -1 :
        print("Error in 'standard_brownian_motion_2d_timeParameters' of 'simulation' : argument 'correlation' is not a correlation")
        return

    no_correlation_2d_increments = np.array([standard_brownian_motion_1d_timeParameters(n_times=n_times, n_paths=n_paths,
                                                                                    final_time=final_time, increments=True,
                                                                                    random_state=random_state),
                                        standard_brownian_motion_1d_timeParameters(n_times=n_times, n_paths=n_paths,
                                                                                    final_time=final_time, increments=True,
                                                                                    random_state=random_state)]) 
    
    correlation_2d_increments = no_correlation_2d_increments.copy()
    correlation_2d_increments[1] = correlation*no_correlation_2d_increments[0] + np.sqrt(1 - correlation**2)*no_correlation_2d_increments[1]
          
    if increments == True :  
        return correlation_2d_increments

    else :
        return np.cumsum(correlation_2d_increments, axis = 1)

#test
"""
N, M = 50, 2
T = 1
rho = -0.9
times = np.arange(N+1)*(T / N)

W2 = standard_brownian_motion_2d_timeParameters(N, M, correlation=rho)
sns.lineplot(x=times, y=W2[0,:,1], color='C0', label='Dimension 1')
sns.lineplot(x=times, y=W2[1,:,1], color='C1', label='Dimension 2')
"""


def standard_brownian_motion_multidim_timeList(time_list, n_paths: int = 1, 
                                        correlation : np.array=None,
                                        cholesky: bool = True,
                                        increments : bool = False,
                                        random_state: np.random.Generator=rng) :
    """Simulated paths of 2d standard brownian motion with correlated components

    Args:
        time_list (array_like): list of times associated with the brownian
        n_paths (int, optional): number of paths. Defaults to 1.
        correlation (np.array, optional): Correlation matrix : symmetric and all coefficients between are float between -1 and 1.
            Diagonal coeff are equal to 1. 
        cholesky (bool): if True then the function suppose the correlation matrix is definite positiv. Defaults to True.
        increments (bool, optional): If True, the function returns the increments of the brownian. Defaults to False.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        Let n be correlation.shape[0].
        'np.array' of shape (n, len(time_list), n_paths) containing paths if increments == 'False', containing the increments otherwise.
    """
    #Some arg validity tests
    if time_list[-1] <=0 :
        print("Error in 'standard_brownian_motion_multidim_timeList' of 'simulation' : arg 'time_list' is not valid (last value not non negativ)")
        return

    if correlation is None : #considering None is the same as 0.
        return standard_brownian_motion_1d_timeList(time_list=time_list, npaths=n_paths,
                                                    increments=increments, random_state=random_state)
    
    correlation = np.array(correlation)
    dimension = correlation.shape[0]

    if np.all( correlation <= 1) and np.all( correlation >= -1) :
        # d dimensionnal (d = 'dimension') brownian motion with independent component
        no_correlation_increments = np.array([standard_brownian_motion_1d_timeList(time_list=time_list, npaths=n_paths,
                                                                                increments=True, 
                                                                                random_state=random_state)
                                            for i in range(dimension)])

        # Square root of correlation matrix
        if cholesky == True :
            correlation_matrix_sqrt = np.linalg.cholesky(correlation)
        else : 
            correlation_matrix_sqrt = (scipy.linalg.sqrtm(correlation))[0]

        correlation_increments = np.einsum('ij,jkl->ikl', correlation_matrix_sqrt, no_correlation_increments)

        if increments == True : return correlation_increments
        else : return np.cumsum(correlation_increments, axis=1)

    else :
        print("Error in 'standard_brownian_motion_multidim_timeList' of 'simulation' : arg 'correlation' is not a correlation matrix")
        return


def standard_brownian_motion_multidim_timeParameters(n_times: int, n_paths : int,
                                                    final_time: float = 1.0, 
                                                    correlation : np.array=None,
                                                    cholesky: bool = True,
                                                    increments : bool = False,
                                                    random_state: np.random.Generator=rng) :
    """Simulated paths of 2d standard brownian motion with correlated components

    Args:
        time_list (array_like): list of times associated with the brownian
        n_paths (int, optional): number of paths. Defaults to 1.
        correlation (np.array, optional): Correlation matrix : symmetric and all coefficients between are float between -1 and 1.
            Diagonal coeff are equal to 1. 
        cholesky (bool): if True then the function suppose the correlation matrix is definite positiv. Defaults to True.
        increments (bool, optional): If True, the function returns the increments of the brownian. Defaults to False.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        Let n be correlation.shape[0].
        'np.array' of shape (n, len(time_list), n_paths) containing paths if increments == 'False', containing the increments otherwise.
    """
    # Some validity checks
    if final_time <=0 :
        print("Error in 'standard_brownian_motion_multidim_timeParameters' of 'simulation' : arg 'final_time' is not valid.")
        return

    if correlation is None : #considering None is the same as 0.
        return standard_brownian_motion_1d_timeParameters(n_times=n_times, n_paths=n_paths, final_time=final_time,
                                                        increments=increments, random_state=random_state)                                   
    
    correlation = np.array(correlation)
    dimension = correlation.shape[0]

    if np.all( correlation <= 1) and np.all( correlation >= -1) :
        # d dimensionnal (d = 'dimension') brownian motion with independent component
        no_correlation_increments = np.array([standard_brownian_motion_1d_timeParameters(n_times=n_times, n_paths=n_paths, 
                                                                                final_time=final_time,
                                                                                increments=True, 
                                                                                random_state=random_state)
                                            for i in range(dimension)])

        # Square root of correlation matrix
        if cholesky == True :
            correlation_matrix_sqrt = np.linalg.cholesky(correlation)
        else : 
            correlation_matrix_sqrt = (scipy.linalg.sqrtm(correlation))[0]

        correlation_increments = np.einsum('ij,jkl->ikl', correlation_matrix_sqrt, no_correlation_increments)

        if increments == True : return correlation_increments
        else : return np.cumsum(correlation_increments, axis=1)

    else :
        print("Error in 'standard_brownian_motion_multidim_timeParameters' of 'simulation' : arg 'correlation' is not a correlation matrix")
        return


def geometric_brownian_motion_1d_timeList(time_list, n_paths: int = 1, 
                                        value_at_0: float=1.0,
                                        drift: float=1.0,
                                        volatility: float=0.0,
                                        increments: bool = False,
                                        random_state: np.random.Generator=rng) :
    """Geometric brownian motion (1 dimension) generator

    Draw 'n_paths' of geometric brownian motion using the independant gaussians generated with numpy.
    Generated using independent increasing increments.

    Args:
        time_list (array_like): non decreasing sequence of non negativ float representing time. 
            This function doesn't check the 'non-decreasing' caracteristic so it won't return a geometric 
            brownian motion if time_list is not non decreasing.
        n_paths (int): number of paths to generate
        value_at_0 (float): value of the geometric brownian motion at time = 0.
        drift (float): drift of the geometric brownian motion. 
        volatility (float): volatility of the geometric brownian motion.
        increments (bool) : Determine if we return the increments array or not.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        Array of float representing the values of the geometric brownian motion at times in the time_list.
    """
    #Partial validity check of time_list
    if time_list[-1] <=0 :
        print("Error in 'geometric_brownian_motion_1d_timeList' of 'simulation' : arg 'time_list' is not valid (last value not non negativ)")
        return
    
    n_times = len(time_list)
    standard_brownian = standard_brownian_motion_1d_timeList(time_list=time_list, n_paths=n_paths, 
                                                                            increments=increments, random_state=random_state)

    if increments == True :
        time_list_increments = time_list - (np.append(0, (time_list[:-1])))
        time_list_increments_array = np.repeat(time_list_increments, n_paths).reshape(n_times, n_paths)

        return value_at_0*np.exp( (drift - (volatility**2)/2)*time_list_increments_array + volatility*standard_brownian)

    else :
        standard_brownian = standard_brownian_motion_1d_timeList(time_list=time_list, n_paths=n_paths, 
                                                                increments=increments, random_state=random_state)
        time_list_array = np.repeat(time_list, n_paths).reshape(n_times, n_paths)

        return value_at_0*np.exp( (drift - (volatility**2)/2)*time_list_array + volatility*standard_brownian)

#test
"""
time_list = np.linspace(0, 2, 10000, endpoint=True)
volatility = .25
drift = .02
S0 = 1

S = geometric_brownian_motion_1d_timeList(time_list=time_list, n_paths=3, value_at_0=S0, drift=drift, volatility=volatility)
plt.plot(time_list, S[:,0])
plt.show()
"""


def geometric_brownian_motion_1d_timeParameters(n_times: int, n_paths : int,
                                                final_time: float = 1.0,
                                                value_at_0: float=1.0,
                                                drift: float=1.0,
                                                volatility: float=0.0,
                                                increments : bool = False,
                                                random_state: np.random.Generator=rng) :
    """ Geometric brownian motion (1 dimension) generator

    Draw 'n_paths' of geometric brownian motion using the independant gaussians generated with numpy.
    Generated using independent increasing increments.

    Args:
        n_times (int): number of timesteps
        n_paths (int): number of paths simulated
        final_time (float, optional): Final time of simulation. Defaults to 1.0.
        value_at_0 (float): value of the geometric brownian motion at time = 0.
        drift (float): drift of the geometric brownian motion. 
        volatility (float): volatility of the geometric brownian motion.
        increments (bool) : Determine if we return the increments array or not.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        Array of float representing the values of the geometric brownian motion at times in the time_list.
    """
    #Validity check of args
    if final_time <=0 :
        print("Error in 'geometric_brownian_motion_1d_timeParameters' of 'simulation' : arg 'final_time' is not valid.")
        return

    step = final_time/n_times
    standard_brownian = standard_brownian_motion_1d_timeParameters(n_times=n_times, n_paths=n_paths, 
                                                                                final_time=final_time,
                                                                                increments=increments, random_state=random_state)
        
    if increments == True :
        return value_at_0*np.exp( (drift - (volatility**2)/2)*step + volatility*standard_brownian_)

    else :
        time_list = np.arange(0, final_time + step, step)
        time_list_array = np.repeat(time_list, n_paths).reshape(len(time_list), n_paths)

        return value_at_0*np.exp( (drift - (volatility**2)/2)*time_list_array + volatility*standard_brownian)

#test
"""
T=2
N=10000
step= T/N
time_list = np.arange(0, T + step, step)
M=3
volatility = .25
drift = .02
S0 = 1

S = geometric_brownian_motion_1d_timeParameters(n_times=N, n_paths=M, final_time=T,
                                                value_at_0=S0, drift=drift, volatility=volatility)
plt.plot(time_list, S[:,0])
plt.show()
"""


def geometric_brownian_motion_2d_timeList(time_list, n_paths: int = 1, 
                                        value_at_0 =1.0,
                                        drift = .02,
                                        volatility = .25,
                                        correlation: float=0.0,
                                        increments: bool = False,
                                        random_state: np.random.Generator=rng) :
    """Geometric brownian motion (2 dimension) generator

    Draw 'n_paths' of geometric brownian motion using the independant gaussians generated with numpy.
    Generated using independent increasing increments.

    Args:
        time_list (array_like): non decreasing sequence of non negativ float representing time. 
            This function doesn't check the 'non-decreasing' caracteristic so it won't return a geometric 
            brownian motion if time_list is not non decreasing.
        n_paths (int): number of paths to generate
        value_at_0 (array-like): values of the geometric brownian motion at time = 0.
        drift (array-like): drifts of the geometric brownian motion. 
        volatility (array-like): volatilities of the geometric brownian motion.
        correlation (float, optional): float between -1 and 1. Correlation between the two components of the brownian. Defaults to 0.0.
        increments (bool) : Determine if we return the increments array or not.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        Array of float representing the values of the geometric brownian motion at times in the time_list.
    """
    #Partial validity check of time_list
    if time_list[-1] <=0 :
        print("Error in 'geometric_brownian_motion_2d_timeList' of 'simulation' : arg 'time_list' is not valid (last value not non negativ)")
        return
    if correlation > 1 or correlation < -1 :
        print("Error in 'geometric_brownian_motion_2d_timeList' of 'simulation' : argument 'correlation' is not a correlation")
        return
    
    n_times = len(time_list)
    standard_brownian = standard_brownian_motion_2d_timeList(time_list=time_list, n_paths=n_paths, 
                                                            correlation=correlation,
                                                            increments=increments, random_state=random_state)
    value_at_0, drift, volatility = np.array(value_at_0), np.array(drift), np.array(volatility)
    
    #Dimensions check and redimensionning 
    if value_at_0.size == 1 :
        value_at_0 = np.repeat(value_at_0, 2)
    if drift.size == 1 :
        drift = np.repeat(drift, 2)
    if volatility.size == 1 :
        volatility = np.repeat(volatility, 2)
    if volatility.size != 2 or drift.size != 2 or value_at_0.size !=2 :
        print("Error in 'geometric_brownian_motion_2d_timeList' of 'simulation' : 'value_at_0', 'drift' or 'volatility' don't have the right size")

    #Distinguish 2 cases                                          
    if increments == True :
        time_list_increments = time_list - (np.append(0, (time_list[:-1])))
        time_list_increments_array = np.repeat(time_list_increments, n_paths).reshape(n_times, n_paths)

        return  [
        value_at_0[i]*np.exp( (drift[i] - (volatility[i]**2)/2)*time_list_increments_array + volatility[i]*standard_brownian[i,:])
        for i in range(2) 
        ]

    else :
        time_list_array = np.repeat(time_list, n_paths).reshape(len(time_list), n_paths)

        return [
        value_at_0[i]*np.exp( (drift[i] - (volatility[i]**2)/2)*time_list_array + volatility[i]*standard_brownian[i,:])
        for i in range(2) 
        ]


def geometric_brownian_motion_2d_timeParameters(n_times: int, n_paths : int,
                                                final_time: float = 1.0,
                                                value_at_0: float=1.0,
                                                drift: float=1.0,
                                                volatility: float=0.0,
                                                correlation: float=0.0,
                                                increments : bool = False,
                                                random_state: np.random.Generator=rng) :
    """ Geometric brownian motion (1 dimension) generator

    Draw 'n_paths' of geometric brownian motion using the independant gaussians generated with numpy.
    Generated using independent increasing increments.

    Args:
        n_times (int): number of timesteps
        n_paths (int): number of paths simulated
        final_time (float, optional): Final time of simulation. Defaults to 1.0.
        value_at_0 (float): value of the geometric brownian motion at time = 0.
        drift (float): drift of the geometric brownian motion. 
        volatility (float): volatility of the geometric brownian motion.
        correlation (float, optional): float between -1 and 1. Correlation between the two components of the brownian. Defaults to 0.0.
        increments (bool) : Determine if we return the increments array or not.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        Array of float representing the values of the geometric brownian motion at times in the time_list.
    """
    #Validity check of args
    if final_time <=0 :
        print("Error in 'geometric_brownian_motion_2d_timeParameters' of 'simulation' : arg 'final_time' is not valid.")
        return
    if correlation > 1 or correlation < -1 :
        print("Error in 'geometric_brownian_motion_2d_timeParameters' of 'simulation' : argument 'correlation' is not a correlation")
        return

    step = final_time/n_times
    standard_brownian = standard_brownian_motion_2d_timeParameters(n_times=n_times, n_paths=n_paths, 
                                                            final_time=final_time, correlation=correlation,
                                                            increments=increments, random_state=random_state)
    value_at_0, drift, volatility = np.array(value_at_0), np.array(drift), np.array(volatility)
    
    #Dimensions check and redimensionning 
    if value_at_0.size == 1 :
        value_at_0 = np.repeat(value_at_0, 2)
    if drift.size == 1 :
        drift = np.repeat(drift, 2)
    if volatility.size == 1 :
        volatility = np.repeat(volatility, 2)
    if volatility.size != 2 or drift.size != 2 or value_at_0.size !=2 :
        print("Error in 'geometric_brownian_motion_2d_timeParameters' of 'simulation' : 'value_at_0', 'drift' or 'volatility' don't have the right size")

    #Distinguish 2 cases                                          
    if increments == True :
        return  [
        value_at_0[i]*np.exp( (drift[i] - (volatility[i]**2)/2)*step + volatility[i]*standard_brownian[i,:])
        for i in range(2) 
        ]

    else :
        time_list = np.arange(0, final_time + step, step)
        time_list_array = np.repeat(time_list, n_paths).reshape(len(time_list), n_paths)

        return [
        value_at_0[i]*np.exp( (drift[i] - (volatility[i]**2)/2)*time_list_array + volatility[i]*standard_brownian[i,:])
        for i in range(2) 
        ]


def geometric_brownian_motion_multidim_timeList(time_list, n_paths: int = 1, 
                                        value_at_0 =1.0, drift = .02,
                                        volatility = .25,
                                        correlation: np.array=None,
                                        cholesky: bool = True,
                                        increments: bool = False,
                                        random_state: np.random.Generator=rng) :
    """Geometric brownian motion (multi dimension) generator

    Draw 'n_paths' of geometric brownian motion using the independant gaussians generated with numpy.
    Generated using independent increasing increments.

    Args:
        time_list (array_like): non decreasing sequence of non negativ float representing time. 
            This function doesn't check the 'non-decreasing' caracteristic so it won't return a geometric 
            brownian motion if time_list is not non decreasing.
        n_paths (int): number of paths to generate
        value_at_0 (array-like): values of the geometric brownian motion at time = 0.
        drift (array-like): drifts of the geometric brownian motion. 
        volatility (array-like): volatilities of the geometric brownian motion.
        correlation (float, optional): float between -1 and 1. Correlation between the two components of the brownian. Defaults to 0.0.
        cholesky (bool): if True then the function suppose the correlation matrix is definite positiv. Defaults to True.
        increments (bool) : Determine if we return the increments array or not.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        Array of float representing the values of the geometric brownian motion at times in the time_list.
        Shape : (dimension = correlation.shape[0], len(time_list), n_paths)
    """
    #Partial validity check of time_list
    if time_list[-1] <=0 :
        print("Error in 'geometric_brownian_motion_multidim_timeList' of 'simulation' : arg 'time_list' is not valid (last value not non negativ)")
        return
    
    dim = correlation.shape[0] #dimension of geometric brownian motion
    n_times = len(time_list)
    standard_brownian = standard_brownian_motion_multidim_timeList(time_list=time_list, n_paths=n_paths, 
                                                            correlation=correlation, cholesky=cholesky,
                                                            increments=increments, random_state=random_state)
    value_at_0, drift, volatility = np.array(value_at_0), np.array(drift), np.array(volatility)
    
    #Dimensions check and redimensionning 
    if value_at_0.size == 1 :
        value_at_0 = np.repeat(value_at_0, dim)
    if drift.size == 1 :
        drift = np.repeat(drift, dim)
    if volatility.size == 1 :
        volatility = np.repeat(volatility, dim)
    if volatility.size != dim or drift.size != dim or value_at_0.size !=dim :
        print("Error in 'geometric_brownian_motion_2d_timeList' of 'simulation' : 'value_at_0', 'drift' or 'volatility' don't have the right size")

    if np.all( correlation <= 1) and np.all( correlation >= -1) :
        #Distinguish 2 cases
        if increments == True :
            time_list_increments = time_list - (np.append(0, (time_list[:-1])))
            time_list_increments_array = np.repeat(time_list_increments, n_paths).reshape(n_times, n_paths)

            return  [
            value_at_0[i]*np.exp( (drift[i] - (volatility[i]**2)/2)*time_list_increments_array + volatility[i]*standard_brownian[i,:])
            for i in range(dim) 
            ]

        else :
            time_list_array = np.repeat(time_list, n_paths).reshape(len(time_list), n_paths)

            return [
            value_at_0[i]*np.exp( (drift[i] - (volatility[i]**2)/2)*time_list_array + volatility[i]*standard_brownian[i,:])
            for i in range(dim) 
            ]
    
    else :
        print("Error in 'geometric_brownian_motion_multidim_timeList' of 'simulation' : arg 'correlation' is not a correlation matrix")
        return


def geometric_brownian_motion_multidim_timeParameters(n_times: int, n_paths : int,
                                                final_time: float = 1.0,
                                                value_at_0 =1.0, drift = .02,
                                                volatility = .25,
                                                correlation: np.array=None,
                                                increments : bool = False,
                                                random_state: np.random.Generator=rng) :
    """ Geometric brownian motion (multi dimension) generator

    Draw 'n_paths' of geometric brownian motion using the independant gaussians generated with numpy.
    Generated using independent increasing increments.

    Args:
        n_times (int): number of timesteps
        n_paths (int): number of paths to generate
        final_time (float, optional): Final time of simulation. Defaults to 1.0.
        value_at_0 (array-like): values of the geometric brownian motion at time = 0.
        drift (array-like): drifts of the geometric brownian motion. 
        volatility (array-like): volatilities of the geometric brownian motion.
        correlation (float, optional): float between -1 and 1. Correlation between the two components of the brownian. Defaults to 0.0.
        cholesky (bool): if True then the function suppose the correlation matrix is definite positiv. Defaults to True.
        increments (bool) : Determine if we return the increments array or not.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        Array of float representing the values of the geometric brownian motion at times in the time_list.
    """
    #Validity check of args
    if final_time <=0 :
        print("Error in 'geometric_brownian_motion_2d_timeParameters' of 'simulation' : arg 'final_time' is not valid.")
        return
    
    dim = correlation.shape[0] #dimension of geometric brownian motion
    step = final_time/n_times
    standard_brownian = standard_brownian_motion_multidim_timeParameters(n_times=n_times, n_paths=n_paths,
                                                            final_time=final_time,
                                                            correlation=correlation, cholesky=cholesky,
                                                            increments=increments, random_state=random_state)
    value_at_0, drift, volatility = np.array(value_at_0), np.array(drift), np.array(volatility)
    
    #Dimensions check and redimensionning 
    if value_at_0.size == 1 :
        value_at_0 = np.repeat(value_at_0, dim)
    if drift.size == 1 :
        drift = np.repeat(drift, dim)
    if volatility.size == 1 :
        volatility = np.repeat(volatility, dim)
    if volatility.size != dim or drift.size != dim or value_at_0.size !=dim :
        print("Error in 'geometric_brownian_motion_2d_timeList' of 'simulation' : 'value_at_0', 'drift' or 'volatility' don't have the right size")

    if np.all( correlation <= 1) and np.all( correlation >= -1) :
        #Distinguish 2 cases
        if increments == True :
            return  [
            value_at_0[i]*np.exp( (drift[i] - (volatility[i]**2)/2)*step + volatility[i]*standard_brownian[i,:])
            for i in range(dim) 
            ]

        else :
            time_list = np.arange(0, final_time + step, step)
            time_list_array = np.repeat(time_list, n_paths).reshape(len(time_list), n_paths)

            return [
            value_at_0[i]*np.exp( (drift[i] - (volatility[i]**2)/2)*time_list_array + volatility[i]*standard_brownian[i,:])
            for i in range(dim) 
            ]
    
    else :
        print("Error in 'geometric_brownian_motion_multidim_timeList' of 'simulation' : arg 'correlation' is not a correlation matrix")
        return


def brownian_bridge_1d_timeList(time_list, n_paths: int = 1, 
                                random_state: np.random.Generator=rng) :
    """Standard brownian bridge (1 dimension) generator

    Draw 'n_paths' of a brownian bridge using the independant gaussians generated with numpy.
    Generated using independent increasing increments.

    Args:
        time_list (array_like): non decreasing sequence of non negativ float representing time. 
            This function doesn't check the 'non-decreasing' caracteristic so it won't return a brownian bridge
            if time_list is not non decreasing.
        n_paths (int): number of paths to generate.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        Array of float representing the values of the brownian bridge at times in the time_list.
    """
    #Partial validity check of time_list
    if time_list[-1] <=0 :
        print("Error in 'brownian_bridge_1d_timeList' of 'simulation' : arg 'time_list' is not valid (last value not non negativ)")
        return

    standard_brownian_motion = standard_brownian_motion_1d_timeList(time_list =time_list, n_paths=n_paths,
                                                                    increments=False, random_state=random_state)                                               
    T = time_list[-1]
    B_T = standard_brownian_motion[-1,:]

    return standard_brownian_motion - (1/T)*time_list*B_T


def brownian_bridge_1d_timeParameters(n_times: int, n_paths : int,
                                    final_time: float = 1.0,
                                    random_state: np.random.Generator=rng) :
    """Standard brownian bridge (1 dimension) generator

    Draw 'n_paths' of standard brownian bridge using the independant gaussians generated with numpy.
    Generated using independent increasing increments.

    Args:
        n_times (int): number of timesteps
        n_paths (int): number of paths simulated
        final_time (float, optional): Final time of simulation. Defaults to 1.0.
        random_state : 'np.random.Generator' used for simulation. Defaults to rng.

    Returns:
        `np.array` of shape `(n_times+1, n_paths)` containing the paths.
    """
    #Validity check of args
    if final_time <=0 :
        print("Error in 'brownian_bridge_1d_timeParameters' of 'simulation' : arg 'final_time' is not valid.")
        return

    step = final_time/n_times
    time_list = np.arange(0, final_time + step, step)
    standard_brownian_motion = standard_brownian_motion_1d_timeParameters(n_times=n_times, n_paths=n_paths,
                                                                    final_time=final_time, 
                                                                    increments=False, random_state=random_state) 
    B_T = standard_brownian_motion[-1,:]

    return standard_brownian_motion - (1/final_time)*time_list*B_T
    

def fractionnal_brownian_motion(hudhe) :
    return




# %%
